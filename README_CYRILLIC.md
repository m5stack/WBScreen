# Class WBScreen for M5Stack UIFlow 1.0

## Introduction

Несмотря на то, что сегодня существуют высокотехнологичные дисплеи с очень высоким разрешением, богатейшей цветовой палитрой и высочайшими частотами обновления, монохромные дисплеи до сих пор остаются популярными как среди профессионалов, так и новичков. Можно отметить два самых очевидных преимущества – одно технологическое, другое визуальное.

Технология монохромных LCD заключается в изменении ориентации жидких кристаллов под действием электрического заряда и отражении светового потока от светоотражающей пленки с обратной стороны. Таким образом, данные дисплеи обеспечивают высокую читаемость при ярком освещении и отсутствие необходимости в подсветке в светлое время суток. Данное преимущество, к сожалению, не распространяется на встроенный дисплей в M5Stack, изготовленный по технологии IPS.

Однако стоит обратить внимание на второе преимущество, которое носит визуальный характер и может быть реализовано на любом цветном дисплее – это эстетичный минимализм. Под данным понятием понимается целая концепция, состоящая из таких вещей, как простота создания, единство палитры, конкретика (поскольку при малом разрешении каждый пиксель имеет значение) и самая интересная – свобода представления (чем меньше деталей известно человеку, тем больше он может вообразить).

Данный класс предназначен для создания виртуального монохромного экрана в среде разработки UIFlow.

## Features

* превосходная совместимость с UIFlow;
* простота подключения и лёгкость использования;
* набор палитр, в числе которых: «LCD подсветка выключена», белая, зелёная (стиль Nokia), синяя (стиль Samsung) и оранжевая (стиль Siemens);
* быстрая отрисовка спрайтов;
* четыре режима прозрачности: непрозрачный, прозрачный внутри контура (например, подводная пещера), прозрачный за контуром (например, рыба), полностью прозрачный (например, пузырёк);
* создание спрайтов из RAW-байтов от WBMP-изображения;
* отсутствие мерцания при обновлении кадра.

> Примечание: сложные режимы прозрачности (0x01, 0x10) будут реализованы позже. Вы можете помочь с этим.

## Installation

### MicroPython

Скопируйте содержимое файла `WBScreen.py` в редактор кода (вкладка Python в [UIFlow](https://flow.m5stack.com)), как приведено на примере ниже:

```
from m5stack import *
from m5ui import *
from uiflow import *

class WBScreen:
	...
```
	
### Blockly

> Примечание: данная возможность будет добавлена в скором времени.

## Usage

Класс `WBScreen` предоставляет следующие методы:

- `__init__(palette: int = 0, screenWidth: int = 320, screenHeight: int = 240, width: int = 84, height: int = 48, dotSize: int = 2, dotSpacing: int = 1)`: конструктор класса инициализирует экземпляр `WBScreen` с необязательными параметрами;

- `Clear()`: очищает буфер виртуального экрана, заполняя его цветом фона из выбранной палитры;

- `Push()`: отправляет содержимое буфера виртуального экрана на физический дисплей;

- `Pixel(x: int, y: int, value: int, width: int, destination: ptr8)`: закрашивает пиксель в 565-буфере;

- `Dot(x: int, y: int, value: int, width: int, destination: ptr8`): закрашивает пиксель в буфере виртуального экрана;

- `Sprite(width: int, height: int, content: ptr8)`: создает спрайт из RAW-данных WBMP-изображения;

- `Slice(source: ptr8, sourceIndex: int, sourceWidthX2: int, destination: ptr8, destinationIndex: int, transparencyMode: int)`: копирует участок изображения из исходного 565-буфера и вставляет его в целевой 565-буфер с заданным режимом прозрачности;

- `Select(x: int, y: int, sprite, transparencyMode: int = 0x00)`: размещает спрайт на экране в заданной позиции с заданным режимом прозрачности.

## Examples

Ниже приведён простейший пример добавления точки на виртуальный экран:

```python
# Создаем экземпляр класса
screen = WBScreen(palette = 1)

# Рисуем точку в буфере виртуального экрана
screen.Dot(10, 10, 0b0, screen.width, screen.window)

# Выводим на физический экран содержимое буфера виртуального экрана
screen.Push()
```
Далее приведён расширенный пример «подводный мир», в котором реализован вывод трёх изображений: водоросли (неподвижное без прозрачности), пузырёк (подвижное с прозрачностью) и рыбка (анимация с прозрачностью):

```
import random

# class WBScreen:
#  ...

# Создаем экземпляр класса
screen = WBScreen(palette = 3)

# RAW-данные трёх WBMP-изображений:

# 1. Неподвижное изображение "водоросли"
seaweed = bytearray([0xFC, 0xFC, 0xFC, 0xFC, 0xDC, 0xCC, 0xEC, 0xEC, 0xEC, 0xE4, 0xE4, 0xCC, 0xDC, 0xDC, 0xCC, 0xEC, 0xCC, 0xDC, 0xD4, 0xC4, 0xCC, 0xEC, 0xAC, 0x84, 0xCC, 0xCC, 0x8C, 0x9C, 0xDC, 0xCC, 0xCC, 0xCC])

# 2. Подвижное изображение "пузырёк"
bubble = bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1F, 0xFB, 0xEF, 0xF7, 0xF7, 0xEF, 0xBB, 0xDF, 0x5D, 0xDB, 0xBD, 0xD7, 0xFD, 0xDF, 0xFD, 0xDF, 0xFD, 0xEF, 0xFB, 0xF7, 0xB7, 0xFB, 0xEF, 0xFC, 0x1F, 0xFF, 0xFF])

# 3. Подвижная анимация "рыбка". Состоит из двух изображений
fish = [bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x3F, 0xFC, 0x7F, 0xF0, 0x3F, 0xEF, 0xDD, 0xDB, 0xEB, 0xDF, 0xF5, 0xE7, 0xEB, 0xF3, 0xDD, 0xF8, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]), bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 0x1F, 0xF0, 0x3B, 0xEF, 0xDB, 0xDB, 0xEB, 0xDF, 0xF3, 0xE7, 0xEB, 0xF3, 0xDB, 0xF8, 0x3B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])]

# Создаём спрайт для seaweed
seaweedSprite = screen.Sprite(6, 32, seaweed)

# Создаём спрайт для bubble
bubbleSprite = screen.Sprite(16, 16, bubble)

# Создаём спрайты для fish
fishSprites = [screen.Sprite(16, 16, fish[0]), screen.Sprite(16, 16, fish[1])]

while True:
  for i in range(24, 48):
    # Копируем спрайт seaweed в буфер виртуального экрана
    screen.Select(15, 16, seaweedSprite, 0x00)
    
    # Копируем спрайт bubble в буфер виртуального экрана
    screen.Select(10 + random.randint(-1, 1), -i, bubbleSprite, 0x11)
    
    if i % 2 == 0:
      # Копируем 0-й спрайт fish в буфер виртуального экрана
      screen.Select(screen.width - i, 5, fishSprites[0])
    else:
      # Копируем 1-й спрайт fish в буфер виртуального экрана
      screen.Select(screen.width - i, 5, fishSprites[1])
    
    # Выводим на физический экран содержимое буфера виртуального экрана
    screen.Push()
    
    # Задержка 50 мс
    wait_ms(50)
```

## Contributing

Если Вы хотите внести свой вклад в развитие данного проекта, пожалуйста, следуйте следующим рекомендациям:

1. Сделайте **Fork** репозитория и **Clone** его на свою локальную машину.
2. Создайте новую **Branch**.
3. Внесите улучшения в код.
4. Пишите чёткие и краткие пояснения к **Commits**.
5. Проверяйте внесённые правки.
6. Не забывайте сделать **Push** свою **Fork** в репозиторий.
7. Можете сделать **Pull Request** в основной репозиторий, пояснив цель и детали Вашего вклада.
8. Убедитесь, что Ваш **Pull Request** соответствует кодовым конвенциям и стандартам оформления проекта.
