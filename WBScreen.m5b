{"category":"WBScreen","color":"#3a88fe","blocks":["__WBScreen_import","__WBScreen_Init","__WBScreen_Sprite","__WBScreen_Select","__WBScreen_Push","__WBScreen_bytearray"],"jscode":"// Block __WBScreen_import\nvar __WBScreen_import_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"import WBScreen\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_import'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_import_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_import'] = function(block) {\n        return `class WBScreen:\n  palettes = [\n    # [byte1, byte0] for 'black', 'white', 'backlight'\n    [[0x00, 0x00], [0x18, 0xe3], [0x21, 0x03]], # \"LCD backlight OFF\"\n    [[0x00, 0x00], [0x6b, 0xac], [0x73, 0xed]], # white\n    [[0x00, 0x00], [0x5c, 0xa6], [0x64, 0xe6]], # green\n    [[0x00, 0x00], [0x22, 0x56], [0x22, 0x77]], # blue\n    [[0x00, 0x00], [0xab, 0x44], [0xB3, 0x84]], # orange\n    [[0xff, 0xff], [0x00, 0x00], [0x00, 0x00]], # white OLED style\n    [[0x7f, 0xdf], [0x00, 0x00], [0x00, 0x00]], # blue OLED style\n    [[0xff, 0xa0], [0x00, 0x00], [0x00, 0x00]]  # yellow OLED style\n  ]\n\n  dSiSp: int\n  dSiSpWindowWidthX2: int\n  dSiSpX2: int\n  dotSize: int\n  dotSpacing: int\n  height: int\n  hSpacing: int\n  palette: int\n  screenHeight: int\n  screenWidth: int\n  vSpacing: int\n  width: int\n  window: ptr8 = None\n  windowBlank: ptr8 = None\n  windowLength: int\n  windowLengthX2: int\n  windowWidth: int\n  windowWidthX2: int\n  windowX0 = [int, int]\n  windowX01: ptr8 = None\n  windowX1 = [int, int]\n  windowY0 = [int, int]\n  windowY01: ptr8 = None\n  windowY1 = [int, int]\n\n  def __init__(self, palette: int = 0, screenWidth: int = 320, screenHeight: int = 240, width: int = 84, height: int = 48, dotSize: int = 2, dotSpacing: int = 1):\n    self.palette = palette\n\n    self.screenWidth = screenWidth\n    self.screenHeight = screenHeight\n\n    self.width = width\n    self.height = height\n\n    self.dotSize = dotSize\n    self.dotSpacing = dotSpacing\n    self.dSiSp = self.dotSize + self.dotSpacing\n\n    self.hSpacing = int((self.screenWidth - (self.width * self.dotSize + self.width)) / 2)\n    self.vSpacing = int((self.screenHeight - (self.height * self.dotSize + self.height)) / 2)\n\n    x0 = self.hSpacing\n    self.windowX0[0] = x0 & 0xFF\n    self.windowX0[1] = (x0 >> 8) & 0xFF\n\n    x1 = self.hSpacing + self.dSiSp * self.width - 1\n    self.windowX1[0] = x1 & 0xFF\n    self.windowX1[1] = (x1 >> 8) & 0xFF\n\n    y0 = self.vSpacing\n    self.windowY0[0] = y0 & 0xFF\n    self.windowY0[1] = (y0 >> 8) & 0xFF\n\n    y1 = self.vSpacing + self.dSiSp * self.height - 1\n    self.windowY1[0] = y1 & 0xFF\n    self.windowY1[1] = (y1 >> 8) & 0xFF\n\n    self.windowX01 = bytearray([self.windowX0[1], self.windowX0[0], self.windowX1[1], self.windowX1[0]])\n    self.windowY01 = bytearray([self.windowY0[1], self.windowY0[0], self.windowY1[1], self.windowY1[0]])\n\n    self.windowWidth = x1 - x0 + 1\n    self.windowLength = self.windowWidth * (y1 - y0 + 1)\n\n    self.window = bytearray(self.windowLength * 2)\n\n    self.dSiSpX2 = self.dSiSp * 2\n    self.windowWidthX2 = self.windowWidth * 2\n    self.windowLengthX2 = self.windowLength * 2\n    self.dSiSpWindowWidthX2 = self.dSiSp * self.windowWidthX2\n\n    self.Clear()\n\n    lcd.fill(self.RGBfrom565((self.palettes[self.palette][2][0] << 8) | self.palettes[self.palette][2][1]))\n\n  def RGBfrom565(self, rgb565):\n    r = (rgb565 >> 11) & 0x1F\n    g = (rgb565 >> 5) & 0x3F\n    b = rgb565 & 0x1F\n\n    r = (r << 3) | (r >> 2)\n    g = (g << 2) | (g >> 4)\n    b = (b << 3) | (b >> 2)\n\n    return (r << 16) | (g << 8) | b\n\n  @micropython.native\n  def Clear(self):\n    if self.windowBlank == None:\n      self.windowBlank = bytearray(self.palettes[self.palette][2] * self.windowLength)\n\n      for i in range(self.height):\n        for j in range(self.width):\n          self.Dot(j, i, 0b1, self.width, self.windowBlank)\n\n    self.window[:] = self.windowBlank[:]\n\n  @micropython.viper\n  def Push(self):\n    lcd.tft_writecmddata(0x2A, memoryview(self.windowX01))\n    lcd.tft_writecmddata(0x2B, memoryview(self.windowY01))\n    lcd.tft_writecmddata(0x2C, memoryview(self.window))\n\n    # So slow part ×_×'\n    windowLengthX2: int = int(self.windowLength) * 2\n    window: ptr8 = self.window\n    windowBlank: ptr8 = self.windowBlank\n\n    for i in range(windowLengthX2):\n      window[i] = windowBlank[i]\n\n  def Pixel(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    destination[index] = self.palettes[self.palette][value][0]\n    destination[index + 1] = self.palettes[self.palette][value][1]\n\n  def GetPixel(self, x: int, y: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    return [destination[index], destination[index + 1]]\n\n  def Dot(self, x: int, y: int, value: int):\n    self.Dot(x, y, value, self.width, self.window)\n\n  def Dot(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    for i in range(self.dotSize):\n      for j in range(self.dotSize):\n        self.Pixel(nx + j, ny + i, value, width, destination)\n\n  def GetDot(self, x: int, y: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    return self.GetPixel(nx, ny, width, destination)\n\n  def Sprite(self, width: int, height: int, content: ptr8, transparencyPoint: [int, int] = None):\n    spriteWidth: int = self.dSiSp * width\n    spriteHeight: int = self.dSiSp * height\n    spriteContent: ptr8 = bytearray(self.palettes[self.palette][2] * (spriteWidth * spriteHeight * 2))\n\n    usefulBits: int = 8 if width > 8 else width\n\n    for by in range((8 if width < 8 else width) * height // 8):\n      for bi in range(usefulBits):\n        index = by * usefulBits + bi\n        x = index % width\n        y = index // width\n        value = (content[by] >> (7 - bi)) & 0b1\n\n        self.Dot(x, y, value, width, spriteContent)\n\n    transparencyMode: int\n\n    if transparencyPoint == None:\n      transparencyMode = 0x00\n\n    elif transparencyPoint == [-1, -1]:\n      transparencyMode = 0x11\n\n    else:\n      transparencyMode = 0x01\n      self.Transparency(transparencyPoint[0], transparencyPoint[1], width, height, spriteContent)\n\n    spriteWidth -= 1\n    spriteHeight -= 1\n\n    return spriteWidth + 1, spriteHeight + 1, spriteContent, transparencyMode\n\n  @micropython.native\n  def Slice(self, source: ptr8, sourceIndex: int, sourceWidthX2: int, destination: ptr8, destinationIndex: int, transparencyMode: int):\n    sourceSlice = memoryview(source)[sourceIndex:sourceIndex + sourceWidthX2]\n    destinationSlice = memoryview(destination)[destinationIndex:destinationIndex + sourceWidthX2]\n\n    if transparencyMode == 0x00:\n      destinationSlice[:] = sourceSlice\n\n    elif transparencyMode == 0x11:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] == self.palettes[self.palette][0][0] and sourceSlice[byte2nd] == self.palettes[self.palette][0][1]:\n          destinationSlice[byte1st] = self.palettes[self.palette][0][0]\n          destinationSlice[byte2nd] = self.palettes[self.palette][0][1]\n\n    else:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] != self.palettes[self.palette][2][0] and sourceSlice[byte2nd] != self.palettes[self.palette][2][1]:\n          destinationSlice[byte1st] = sourceSlice[byte1st]\n          destinationSlice[byte2nd] = sourceSlice[byte2nd]\n\n  @micropython.native\n  def Select(self, x: int, y: int, sprite):\n    width: int = sprite[0]\n    height: int = sprite[1]\n    content565: ptr8 = sprite[2]\n    transparencyMode: int = sprite[3]\n\n    sourceWidthX2: int = width * 2\n\n    for i in range(height):\n      sourceIndex = i * sourceWidthX2\n      destinationIndex = i * self.windowWidthX2\n\n      destinationIndex += x * self.dSiSpX2\n      destinationIndex += y * self.dSiSpWindowWidthX2\n\n      self.Slice(content565, sourceIndex, sourceWidthX2, self.window, destinationIndex, transparencyMode)\n\n  def Transparency(self, x: int, y: int, width: int, height: int, destination: ptr8):\n    startColor = self.GetDot(x, y, width, destination)\n\n    if startColor == self.palettes[self.palette][2]:\n      return\n\n    stack = [(x, y)]\n\n    while stack:\n      currentX, currentY = stack.pop()\n\n      currentColor = self.GetDot(currentX, currentY, width, destination)\n\n      if currentColor == self.palettes[self.palette][2]:\n        continue\n\n      self.Dot(currentX, currentY, 2, width, destination)\n\n      neighborsDots = [\n        (currentX, currentY - 1),\n        (currentX, currentY + 1),\n        (currentX - 1, currentY),\n        (currentX + 1, currentY)\n      ]\n\n      for neighborX, neighborY in neighborsDots:\n        if neighborX >= 0 and neighborX < width and neighborY >= 0 and neighborY < height:\n          neighborColor = self.GetDot(neighborX, neighborY, width, destination)\n\n          if neighborColor == startColor:\n            stack.append((neighborX, neighborY))\n` + \"\\n\";\n};\n\n// Block __WBScreen_Init\nvar __WBScreen_Init_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Init\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"name\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"name\"\n        }\n    ],\n    \"message2\": \"%1 %2\",\n    \"args2\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"palette\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"palette\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_Init'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_Init_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_Init'] = function(block) {\n    var name = block.getFieldValue('name');\nvar palette = block.getFieldValue('palette');\n    return `${name} = WBScreen(palette = ${palette})\n` + \"\\n\";\n};\n\n// Block __WBScreen_Sprite\nvar __WBScreen_Sprite_json = {\n    \"output\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Sprite\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"name\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"name\"\n        }\n    ],\n    \"message2\": \"%1 %2\",\n    \"args2\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"width\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"width\"\n        }\n    ],\n    \"message3\": \"%1 %2\",\n    \"args3\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"height\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"height\"\n        }\n    ],\n    \"message4\": \"%1 %2\",\n    \"args4\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"content\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"content\"\n        }\n    ],\n    \"message5\": \"%1 %2\",\n    \"args5\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"transparencyPoint\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"transparencyPoint\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_Sprite'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_Sprite_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_Sprite'] = function(block) {\n    var name = block.getFieldValue('name');\nvar width = Blockly.Python.valueToCode(block, 'width', Blockly.Python.ORDER_NONE);\nvar height = Blockly.Python.valueToCode(block, 'height', Blockly.Python.ORDER_NONE);\nvar content = Blockly.Python.valueToCode(block, 'content', Blockly.Python.ORDER_NONE);\nvar transparencyPoint = Blockly.Python.valueToCode(block, 'transparencyPoint', Blockly.Python.ORDER_NONE);\n    return [`${name}.Sprite(${width}, ${height}, ${content}, ${transparencyPoint})\n`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n// Block __WBScreen_Select\nvar __WBScreen_Select_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Select\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"name\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"name\"\n        }\n    ],\n    \"message2\": \"%1 %2\",\n    \"args2\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"x\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"x\"\n        }\n    ],\n    \"message3\": \"%1 %2\",\n    \"args3\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"y\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"y\"\n        }\n    ],\n    \"message4\": \"%1 %2\",\n    \"args4\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"sprite\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"sprite\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_Select'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_Select_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_Select'] = function(block) {\n    var name = block.getFieldValue('name');\nvar x = Blockly.Python.valueToCode(block, 'x', Blockly.Python.ORDER_NONE);\nvar y = Blockly.Python.valueToCode(block, 'y', Blockly.Python.ORDER_NONE);\nvar sprite = Blockly.Python.valueToCode(block, 'sprite', Blockly.Python.ORDER_NONE);\n    return `${name}.Select(${x}, ${y}, ${sprite})\n` + \"\\n\";\n};\n\n// Block __WBScreen_Push\nvar __WBScreen_Push_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"Push\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"name\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"name\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_Push'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_Push_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_Push'] = function(block) {\n    var name = block.getFieldValue('name');\n    return `${name}.Push()\n` + \"\\n\";\n};\n\n// Block __WBScreen_bytearray\nvar __WBScreen_bytearray_json = {\n    \"output\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"bytearray\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"content\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"content\"\n        }\n    ],\n    \"colour\": \"#3a88fe\"\n};\n\nwindow['Blockly'].Blocks['__WBScreen_bytearray'] = {\n    init: function() {\n        this.jsonInit(__WBScreen_bytearray_json);\n    }\n};\n\nwindow['Blockly'].Python['__WBScreen_bytearray'] = function(block) {\n    var content = block.getFieldValue('content');\n    return [`bytearray([${content}])\n`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","code":{"import":["window['Blockly'].Python['__WBScreen_import'] = function(block) {\n        return `class WBScreen:\n  palettes = [\n    # [byte1, byte0] for 'black', 'white', 'backlight'\n    [[0x00, 0x00], [0x18, 0xe3], [0x21, 0x03]], # \"LCD backlight OFF\"\n    [[0x00, 0x00], [0x6b, 0xac], [0x73, 0xed]], # white\n    [[0x00, 0x00], [0x5c, 0xa6], [0x64, 0xe6]], # green\n    [[0x00, 0x00], [0x22, 0x56], [0x22, 0x77]], # blue\n    [[0x00, 0x00], [0xab, 0x44], [0xB3, 0x84]], # orange\n    [[0xff, 0xff], [0x00, 0x00], [0x00, 0x00]], # white OLED style\n    [[0x7f, 0xdf], [0x00, 0x00], [0x00, 0x00]], # blue OLED style\n    [[0xff, 0xa0], [0x00, 0x00], [0x00, 0x00]]  # yellow OLED style\n  ]\n\n  dSiSp: int\n  dSiSpWindowWidthX2: int\n  dSiSpX2: int\n  dotSize: int\n  dotSpacing: int\n  height: int\n  hSpacing: int\n  palette: int\n  screenHeight: int\n  screenWidth: int\n  vSpacing: int\n  width: int\n  window: ptr8 = None\n  windowBlank: ptr8 = None\n  windowLength: int\n  windowLengthX2: int\n  windowWidth: int\n  windowWidthX2: int\n  windowX0 = [int, int]\n  windowX01: ptr8 = None\n  windowX1 = [int, int]\n  windowY0 = [int, int]\n  windowY01: ptr8 = None\n  windowY1 = [int, int]\n\n  def __init__(self, palette: int = 0, screenWidth: int = 320, screenHeight: int = 240, width: int = 84, height: int = 48, dotSize: int = 2, dotSpacing: int = 1):\n    self.palette = palette\n\n    self.screenWidth = screenWidth\n    self.screenHeight = screenHeight\n\n    self.width = width\n    self.height = height\n\n    self.dotSize = dotSize\n    self.dotSpacing = dotSpacing\n    self.dSiSp = self.dotSize + self.dotSpacing\n\n    self.hSpacing = int((self.screenWidth - (self.width * self.dotSize + self.width)) / 2)\n    self.vSpacing = int((self.screenHeight - (self.height * self.dotSize + self.height)) / 2)\n\n    x0 = self.hSpacing\n    self.windowX0[0] = x0 & 0xFF\n    self.windowX0[1] = (x0 >> 8) & 0xFF\n\n    x1 = self.hSpacing + self.dSiSp * self.width - 1\n    self.windowX1[0] = x1 & 0xFF\n    self.windowX1[1] = (x1 >> 8) & 0xFF\n\n    y0 = self.vSpacing\n    self.windowY0[0] = y0 & 0xFF\n    self.windowY0[1] = (y0 >> 8) & 0xFF\n\n    y1 = self.vSpacing + self.dSiSp * self.height - 1\n    self.windowY1[0] = y1 & 0xFF\n    self.windowY1[1] = (y1 >> 8) & 0xFF\n\n    self.windowX01 = bytearray([self.windowX0[1], self.windowX0[0], self.windowX1[1], self.windowX1[0]])\n    self.windowY01 = bytearray([self.windowY0[1], self.windowY0[0], self.windowY1[1], self.windowY1[0]])\n\n    self.windowWidth = x1 - x0 + 1\n    self.windowLength = self.windowWidth * (y1 - y0 + 1)\n\n    self.window = bytearray(self.windowLength * 2)\n\n    self.dSiSpX2 = self.dSiSp * 2\n    self.windowWidthX2 = self.windowWidth * 2\n    self.windowLengthX2 = self.windowLength * 2\n    self.dSiSpWindowWidthX2 = self.dSiSp * self.windowWidthX2\n\n    self.Clear()\n\n    lcd.fill(self.RGBfrom565((self.palettes[self.palette][2][0] << 8) | self.palettes[self.palette][2][1]))\n\n  def RGBfrom565(self, rgb565):\n    r = (rgb565 >> 11) & 0x1F\n    g = (rgb565 >> 5) & 0x3F\n    b = rgb565 & 0x1F\n\n    r = (r << 3) | (r >> 2)\n    g = (g << 2) | (g >> 4)\n    b = (b << 3) | (b >> 2)\n\n    return (r << 16) | (g << 8) | b\n\n  @micropython.native\n  def Clear(self):\n    if self.windowBlank == None:\n      self.windowBlank = bytearray(self.palettes[self.palette][2] * self.windowLength)\n\n      for i in range(self.height):\n        for j in range(self.width):\n          self.Dot(j, i, 0b1, self.width, self.windowBlank)\n\n    self.window[:] = self.windowBlank[:]\n\n  @micropython.viper\n  def Push(self):\n    lcd.tft_writecmddata(0x2A, memoryview(self.windowX01))\n    lcd.tft_writecmddata(0x2B, memoryview(self.windowY01))\n    lcd.tft_writecmddata(0x2C, memoryview(self.window))\n\n    # So slow part ×_×'\n    windowLengthX2: int = int(self.windowLength) * 2\n    window: ptr8 = self.window\n    windowBlank: ptr8 = self.windowBlank\n\n    for i in range(windowLengthX2):\n      window[i] = windowBlank[i]\n\n  def Pixel(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    destination[index] = self.palettes[self.palette][value][0]\n    destination[index + 1] = self.palettes[self.palette][value][1]\n\n  def GetPixel(self, x: int, y: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    return [destination[index], destination[index + 1]]\n\n  def Dot(self, x: int, y: int, value: int):\n    self.Dot(x, y, value, self.width, self.window)\n\n  def Dot(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    for i in range(self.dotSize):\n      for j in range(self.dotSize):\n        self.Pixel(nx + j, ny + i, value, width, destination)\n\n  def GetDot(self, x: int, y: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    return self.GetPixel(nx, ny, width, destination)\n\n  def Sprite(self, width: int, height: int, content: ptr8, transparencyPoint: [int, int] = None):\n    spriteWidth: int = self.dSiSp * width\n    spriteHeight: int = self.dSiSp * height\n    spriteContent: ptr8 = bytearray(self.palettes[self.palette][2] * (spriteWidth * spriteHeight * 2))\n\n    usefulBits: int = 8 if width > 8 else width\n\n    for by in range((8 if width < 8 else width) * height // 8):\n      for bi in range(usefulBits):\n        index = by * usefulBits + bi\n        x = index % width\n        y = index // width\n        value = (content[by] >> (7 - bi)) & 0b1\n\n        self.Dot(x, y, value, width, spriteContent)\n\n    transparencyMode: int\n\n    if transparencyPoint == None:\n      transparencyMode = 0x00\n\n    elif transparencyPoint == [-1, -1]:\n      transparencyMode = 0x11\n\n    else:\n      transparencyMode = 0x01\n      self.Transparency(transparencyPoint[0], transparencyPoint[1], width, height, spriteContent)\n\n    spriteWidth -= 1\n    spriteHeight -= 1\n\n    return spriteWidth + 1, spriteHeight + 1, spriteContent, transparencyMode\n\n  @micropython.native\n  def Slice(self, source: ptr8, sourceIndex: int, sourceWidthX2: int, destination: ptr8, destinationIndex: int, transparencyMode: int):\n    sourceSlice = memoryview(source)[sourceIndex:sourceIndex + sourceWidthX2]\n    destinationSlice = memoryview(destination)[destinationIndex:destinationIndex + sourceWidthX2]\n\n    if transparencyMode == 0x00:\n      destinationSlice[:] = sourceSlice\n\n    elif transparencyMode == 0x11:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] == self.palettes[self.palette][0][0] and sourceSlice[byte2nd] == self.palettes[self.palette][0][1]:\n          destinationSlice[byte1st] = self.palettes[self.palette][0][0]\n          destinationSlice[byte2nd] = self.palettes[self.palette][0][1]\n\n    else:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] != self.palettes[self.palette][2][0] and sourceSlice[byte2nd] != self.palettes[self.palette][2][1]:\n          destinationSlice[byte1st] = sourceSlice[byte1st]\n          destinationSlice[byte2nd] = sourceSlice[byte2nd]\n\n  @micropython.native\n  def Select(self, x: int, y: int, sprite):\n    width: int = sprite[0]\n    height: int = sprite[1]\n    content565: ptr8 = sprite[2]\n    transparencyMode: int = sprite[3]\n\n    sourceWidthX2: int = width * 2\n\n    for i in range(height):\n      sourceIndex = i * sourceWidthX2\n      destinationIndex = i * self.windowWidthX2\n\n      destinationIndex += x * self.dSiSpX2\n      destinationIndex += y * self.dSiSpWindowWidthX2\n\n      self.Slice(content565, sourceIndex, sourceWidthX2, self.window, destinationIndex, transparencyMode)\n\n  def Transparency(self, x: int, y: int, width: int, height: int, destination: ptr8):\n    startColor = self.GetDot(x, y, width, destination)\n\n    if startColor == self.palettes[self.palette][2]:\n      return\n\n    stack = [(x, y)]\n\n    while stack:\n      currentX, currentY = stack.pop()\n\n      currentColor = self.GetDot(currentX, currentY, width, destination)\n\n      if currentColor == self.palettes[self.palette][2]:\n        continue\n\n      self.Dot(currentX, currentY, 2, width, destination)\n\n      neighborsDots = [\n        (currentX, currentY - 1),\n        (currentX, currentY + 1),\n        (currentX - 1, currentY),\n        (currentX + 1, currentY)\n      ]\n\n      for neighborX, neighborY in neighborsDots:\n        if neighborX >= 0 and neighborX < width and neighborY >= 0 and neighborY < height:\n          neighborColor = self.GetDot(neighborX, neighborY, width, destination)\n\n          if neighborColor == startColor:\n            stack.append((neighborX, neighborY))\n` + \"\\n\";\n};\n\n","class WBScreen:\n  palettes = [\n    # [byte1, byte0] for 'black', 'white', 'backlight'\n    [[0x00, 0x00], [0x18, 0xe3], [0x21, 0x03]], # \"LCD backlight OFF\"\n    [[0x00, 0x00], [0x6b, 0xac], [0x73, 0xed]], # white\n    [[0x00, 0x00], [0x5c, 0xa6], [0x64, 0xe6]], # green\n    [[0x00, 0x00], [0x22, 0x56], [0x22, 0x77]], # blue\n    [[0x00, 0x00], [0xab, 0x44], [0xB3, 0x84]], # orange\n    [[0xff, 0xff], [0x00, 0x00], [0x00, 0x00]], # white OLED style\n    [[0x7f, 0xdf], [0x00, 0x00], [0x00, 0x00]], # blue OLED style\n    [[0xff, 0xa0], [0x00, 0x00], [0x00, 0x00]]  # yellow OLED style\n  ]\n\n  dSiSp: int\n  dSiSpWindowWidthX2: int\n  dSiSpX2: int\n  dotSize: int\n  dotSpacing: int\n  height: int\n  hSpacing: int\n  palette: int\n  screenHeight: int\n  screenWidth: int\n  vSpacing: int\n  width: int\n  window: ptr8 = None\n  windowBlank: ptr8 = None\n  windowLength: int\n  windowLengthX2: int\n  windowWidth: int\n  windowWidthX2: int\n  windowX0 = [int, int]\n  windowX01: ptr8 = None\n  windowX1 = [int, int]\n  windowY0 = [int, int]\n  windowY01: ptr8 = None\n  windowY1 = [int, int]\n\n  def __init__(self, palette: int = 0, screenWidth: int = 320, screenHeight: int = 240, width: int = 84, height: int = 48, dotSize: int = 2, dotSpacing: int = 1):\n    self.palette = palette\n\n    self.screenWidth = screenWidth\n    self.screenHeight = screenHeight\n\n    self.width = width\n    self.height = height\n\n    self.dotSize = dotSize\n    self.dotSpacing = dotSpacing\n    self.dSiSp = self.dotSize + self.dotSpacing\n\n    self.hSpacing = int((self.screenWidth - (self.width * self.dotSize + self.width)) / 2)\n    self.vSpacing = int((self.screenHeight - (self.height * self.dotSize + self.height)) / 2)\n\n    x0 = self.hSpacing\n    self.windowX0[0] = x0 & 0xFF\n    self.windowX0[1] = (x0 >> 8) & 0xFF\n\n    x1 = self.hSpacing + self.dSiSp * self.width - 1\n    self.windowX1[0] = x1 & 0xFF\n    self.windowX1[1] = (x1 >> 8) & 0xFF\n\n    y0 = self.vSpacing\n    self.windowY0[0] = y0 & 0xFF\n    self.windowY0[1] = (y0 >> 8) & 0xFF\n\n    y1 = self.vSpacing + self.dSiSp * self.height - 1\n    self.windowY1[0] = y1 & 0xFF\n    self.windowY1[1] = (y1 >> 8) & 0xFF\n\n    self.windowX01 = bytearray([self.windowX0[1], self.windowX0[0], self.windowX1[1], self.windowX1[0]])\n    self.windowY01 = bytearray([self.windowY0[1], self.windowY0[0], self.windowY1[1], self.windowY1[0]])\n\n    self.windowWidth = x1 - x0 + 1\n    self.windowLength = self.windowWidth * (y1 - y0 + 1)\n\n    self.window = bytearray(self.windowLength * 2)\n\n    self.dSiSpX2 = self.dSiSp * 2\n    self.windowWidthX2 = self.windowWidth * 2\n    self.windowLengthX2 = self.windowLength * 2\n    self.dSiSpWindowWidthX2 = self.dSiSp * self.windowWidthX2\n\n    self.Clear()\n\n    lcd.fill(self.RGBfrom565((self.palettes[self.palette][2][0] << 8) | self.palettes[self.palette][2][1]))\n\n  def RGBfrom565(self, rgb565):\n    r = (rgb565 >> 11) & 0x1F\n    g = (rgb565 >> 5) & 0x3F\n    b = rgb565 & 0x1F\n\n    r = (r << 3) | (r >> 2)\n    g = (g << 2) | (g >> 4)\n    b = (b << 3) | (b >> 2)\n\n    return (r << 16) | (g << 8) | b\n\n  @micropython.native\n  def Clear(self):\n    if self.windowBlank == None:\n      self.windowBlank = bytearray(self.palettes[self.palette][2] * self.windowLength)\n\n      for i in range(self.height):\n        for j in range(self.width):\n          self.Dot(j, i, 0b1, self.width, self.windowBlank)\n\n    self.window[:] = self.windowBlank[:]\n\n  @micropython.viper\n  def Push(self):\n    lcd.tft_writecmddata(0x2A, memoryview(self.windowX01))\n    lcd.tft_writecmddata(0x2B, memoryview(self.windowY01))\n    lcd.tft_writecmddata(0x2C, memoryview(self.window))\n\n    # So slow part ×_×'\n    windowLengthX2: int = int(self.windowLength) * 2\n    window: ptr8 = self.window\n    windowBlank: ptr8 = self.windowBlank\n\n    for i in range(windowLengthX2):\n      window[i] = windowBlank[i]\n\n  def Pixel(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    destination[index] = self.palettes[self.palette][value][0]\n    destination[index + 1] = self.palettes[self.palette][value][1]\n\n  def GetPixel(self, x: int, y: int, width: int, destination: ptr8):\n    index = (width * y + x) * 2\n\n    return [destination[index], destination[index + 1]]\n\n  def Dot(self, x: int, y: int, value: int):\n    self.Dot(x, y, value, self.width, self.window)\n\n  def Dot(self, x: int, y: int, value: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    for i in range(self.dotSize):\n      for j in range(self.dotSize):\n        self.Pixel(nx + j, ny + i, value, width, destination)\n\n  def GetDot(self, x: int, y: int, width: int, destination: ptr8):\n    width *= self.dSiSp\n\n    nx: int = self.dSiSp * x\n    ny: int = self.dSiSp * y\n\n    return self.GetPixel(nx, ny, width, destination)\n\n  def Sprite(self, width: int, height: int, content: ptr8, transparencyPoint: [int, int] = None):\n    spriteWidth: int = self.dSiSp * width\n    spriteHeight: int = self.dSiSp * height\n    spriteContent: ptr8 = bytearray(self.palettes[self.palette][2] * (spriteWidth * spriteHeight * 2))\n\n    usefulBits: int = 8 if width > 8 else width\n\n    for by in range((8 if width < 8 else width) * height // 8):\n      for bi in range(usefulBits):\n        index = by * usefulBits + bi\n        x = index % width\n        y = index // width\n        value = (content[by] >> (7 - bi)) & 0b1\n\n        self.Dot(x, y, value, width, spriteContent)\n\n    transparencyMode: int\n\n    if transparencyPoint == None:\n      transparencyMode = 0x00\n\n    elif transparencyPoint == [-1, -1]:\n      transparencyMode = 0x11\n\n    else:\n      transparencyMode = 0x01\n      self.Transparency(transparencyPoint[0], transparencyPoint[1], width, height, spriteContent)\n\n    spriteWidth -= 1\n    spriteHeight -= 1\n\n    return spriteWidth + 1, spriteHeight + 1, spriteContent, transparencyMode\n\n  @micropython.native\n  def Slice(self, source: ptr8, sourceIndex: int, sourceWidthX2: int, destination: ptr8, destinationIndex: int, transparencyMode: int):\n    sourceSlice = memoryview(source)[sourceIndex:sourceIndex + sourceWidthX2]\n    destinationSlice = memoryview(destination)[destinationIndex:destinationIndex + sourceWidthX2]\n\n    if transparencyMode == 0x00:\n      destinationSlice[:] = sourceSlice\n\n    elif transparencyMode == 0x11:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] == self.palettes[self.palette][0][0] and sourceSlice[byte2nd] == self.palettes[self.palette][0][1]:\n          destinationSlice[byte1st] = self.palettes[self.palette][0][0]\n          destinationSlice[byte2nd] = self.palettes[self.palette][0][1]\n\n    else:\n      for byteCouple in range(sourceWidthX2 // 2):\n        byte1st = byteCouple * 2\n        byte2nd = byte1st + 1\n\n        if sourceSlice[byte1st] != self.palettes[self.palette][2][0] and sourceSlice[byte2nd] != self.palettes[self.palette][2][1]:\n          destinationSlice[byte1st] = sourceSlice[byte1st]\n          destinationSlice[byte2nd] = sourceSlice[byte2nd]\n\n  @micropython.native\n  def Select(self, x: int, y: int, sprite):\n    width: int = sprite[0]\n    height: int = sprite[1]\n    content565: ptr8 = sprite[2]\n    transparencyMode: int = sprite[3]\n\n    sourceWidthX2: int = width * 2\n\n    for i in range(height):\n      sourceIndex = i * sourceWidthX2\n      destinationIndex = i * self.windowWidthX2\n\n      destinationIndex += x * self.dSiSpX2\n      destinationIndex += y * self.dSiSpWindowWidthX2\n\n      self.Slice(content565, sourceIndex, sourceWidthX2, self.window, destinationIndex, transparencyMode)\n\n  def Transparency(self, x: int, y: int, width: int, height: int, destination: ptr8):\n    startColor = self.GetDot(x, y, width, destination)\n\n    if startColor == self.palettes[self.palette][2]:\n      return\n\n    stack = [(x, y)]\n\n    while stack:\n      currentX, currentY = stack.pop()\n\n      currentColor = self.GetDot(currentX, currentY, width, destination)\n\n      if currentColor == self.palettes[self.palette][2]:\n        continue\n\n      self.Dot(currentX, currentY, 2, width, destination)\n\n      neighborsDots = [\n        (currentX, currentY - 1),\n        (currentX, currentY + 1),\n        (currentX - 1, currentY),\n        (currentX + 1, currentY)\n      ]\n\n      for neighborX, neighborY in neighborsDots:\n        if neighborX >= 0 and neighborX < width and neighborY >= 0 and neighborY < height:\n          neighborColor = self.GetDot(neighborX, neighborY, width, destination)\n\n          if neighborColor == startColor:\n            stack.append((neighborX, neighborY))\n"],"Init":["window['Blockly'].Python['__WBScreen_Init'] = function(block) {\n    var name = block.getFieldValue('name');\nvar palette = block.getFieldValue('palette');\n    return `${name} = WBScreen(palette = ${palette})\n` + \"\\n\";\n};\n\n","${name} = WBScreen(palette = ${palette})\n"],"Sprite":["window['Blockly'].Python['__WBScreen_Sprite'] = function(block) {\n    var name = block.getFieldValue('name');\nvar width = Blockly.Python.valueToCode(block, 'width', Blockly.Python.ORDER_NONE);\nvar height = Blockly.Python.valueToCode(block, 'height', Blockly.Python.ORDER_NONE);\nvar content = Blockly.Python.valueToCode(block, 'content', Blockly.Python.ORDER_NONE);\nvar transparencyPoint = Blockly.Python.valueToCode(block, 'transparencyPoint', Blockly.Python.ORDER_NONE);\n    return [`${name}.Sprite(${width}, ${height}, ${content}, ${transparencyPoint})\n`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","${name}.Sprite(${width}, ${height}, ${content}, ${transparencyPoint})\n"],"Select":["window['Blockly'].Python['__WBScreen_Select'] = function(block) {\n    var name = block.getFieldValue('name');\nvar x = Blockly.Python.valueToCode(block, 'x', Blockly.Python.ORDER_NONE);\nvar y = Blockly.Python.valueToCode(block, 'y', Blockly.Python.ORDER_NONE);\nvar sprite = Blockly.Python.valueToCode(block, 'sprite', Blockly.Python.ORDER_NONE);\n    return `${name}.Select(${x}, ${y}, ${sprite})\n` + \"\\n\";\n};\n\n","${name}.Select(${x}, ${y}, ${sprite})\n"],"Push":["window['Blockly'].Python['__WBScreen_Push'] = function(block) {\n    var name = block.getFieldValue('name');\n    return `${name}.Push()\n` + \"\\n\";\n};\n\n","${name}.Push()\n"],"bytearray":["window['Blockly'].Python['__WBScreen_bytearray'] = function(block) {\n    var content = block.getFieldValue('content');\n    return [`bytearray([${content}])\n`, Blockly.Python.ORDER_CONDITIONAL]\n};\n\n","bytearray([${content}])\n"]}}